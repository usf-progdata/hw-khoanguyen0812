<!-- BMW: You are missing your YAML block at the top of your file. Please knit your script to both html_document and github_document. -->

<!-- BMW: The knitted html file you have isn't the final version based on this script. -->

# Homework 03

You will analyze data looking at the relationship between **green reputation** and three personality traits--**compassion**, **intellectual curiosity**, and **openness to experiences**.
The dataset includes data from **students** and **non-students**.

```{r}
dictionary <- readr::read_csv("green_dictionary.csv")
green_data <- readr::read_csv("green_data.csv")
library(tidyverse) # BMW: library(tidyverse) already loads dplyr, tibble, tidyr, and ggplot. You don't need both. 
library(psychTools) # BMW: I'm not sure why you loaded psychTools?
library(scales)
library(dplyr)
library(tidyr)
library(tibble)
library(scales)
library(ggplot2)
library(gridExtra)
```

For your assignment, do the following.

### 1. Inspect the item responses (e.g., with graphs or by summarizing distinct values). 
  
  > I started by transforming the dataframe into Tibble.

<!-- BMW: Stylistically, be sparing with block quotes. Just use regular text -- it's easier to read. -->

```{r}
as_tibble(green_data) # BMW: It was already a tibble. But a bigger deal is that you didn't assign the result, so it wasn't saved. 
```


  > I then check the summary of the data 
  
```{r}
green_data %>% 
  summary()
```

  > I noticed in the dictionary, there is a reverse Keying so I decided to reverse the codes before I try to intrepret anymore data.
  
```{r}
green_data %>% 
mutate(student = recode(student, "1" = "Not_Student", "2" = "Student", .missing = "No_Response", .default = "Unknown")) %>% 
  select(id, student)
```

```{r}
reversed <- dictionary %>% 
  filter(Keying == -1 | Keying == -2) %>% 
  pull(Item)
``` 

```{r}
green_data %>% 
  mutate(across(all_of(reversed),
                ~ recode(.x, "5" = 1, "4" = 2, "3" = 3, "2" = 4, "1" = 5),
                .names = "{.col}r")) %>% 
  summary()
```

  > Not sure why I was doing all of that work but I decided to check the graph for abnormalities. 
  
```{r}
green_data %>% 
  ggplot() +
  aes(x= comp2) +
  geom_histogram()
```

     Is anything unusual?

#### _Most of the students coding are done in question 2. Refer to question 2 for more information_

> Yes, there is something unusual, the student categories have some listed as NA with all missing values or partially have values. The ones with all NA value throughout the result can be assumed to have been removed while the ones who have partial data are assumed to be unwilling to answer the question. This makes coding much harder as there are currently no sufficient ways to deal with this issue (not as far as the content and knowledge being taught in the clas up until this point).


> Some data are in the -99 which is outside of dictionary Keying and other explainable computation which is affecting the data's characteristic as a whole.

### 2. Compute total scores for the four scales. 
     Recode variables as needed.

 > I started with the basic of what I knew here.
 
```{r}
reversed <- dictionary %>% 
  filter(Keying == -1 | Keying == -2) %>% 
  pull(Item)
``` 

 > I then recoded everything that is needed to be recoded.
  
```{r}
green_data %>% 
  mutate(across(everything(),
                ~na_if(.x, -99))) %>% 
  summary()
```

```{r}
green_data %>% 
mutate(student = recode(student, "1" = "Not_Student", "2" = "Student", .missing = "No_Response", .default = "Unknown")) %>% 
  select(id, student)
```

```{r}
green_data %>% 
  mutate(across(all_of(reversed),
                ~ recode(.x, "5" = 1,
                         "4" = 2,
                         "3" = 3,
                         "2" = 4,
                         "1" = 5),
                .names = "{.col}r"))
```

  > I decided to make a new data frame with the recoded data.

<!-- BMW: I'm not sure why you have all of the code above that is redundant wit the chunk below. In your final script, you only need to include the final parts of your work that you retain. -->
  
```{r}
new_green_data <- green_data %>% 
  mutate(across(everything(),
                ~na_if(.x, -99))) %>%
  mutate(student = recode(student, "1" = "Not_Student", "2" = "Student", .missing = "No_Response", .default = "Unknown")) %>%
  mutate(across(all_of(reversed),
                ~ recode(.x, "5" = 1,
                         "4" = 2,
                         "3" = 3,
                         "2" = 4,
                         "1" = 5),
                .names = "{.col}r"))
```


  > Since I have the necessary information for the calculation, I decided to make a list of the newly reversed columns into a new variable along with a list of the excluding variables for some of the columns for easier and faster coding process (if such lists are needed).
  
```{r} 
reversed_columns <- c("green2r", "comp6r", "comp7r", "comp8r", "comp9r", "comp10r", "intel7r", "intel8r", "intel9r", "intel10r", "open7r", "open8r", "open9r", "open10r")
comp_ex <- c("comp6", "comp7", "comp8", "comp9", "comp10")
intel_ex <- c("intel7", "intel8", "intel9", "intel10")
open_ex <- c("open7", "open8", "open9", "open10")
```     

  > I started to do my calculation here with the new exclusion lists and the new data frame ( I decided to manually typed in every variables that were reverse so that way, I can see what I did if the code does not work on me).
  
```{r}
new_green_data %>%
  rowwise() %>%
  mutate(
    green_tot = mean(c(green1, green2r, green3, green4, green5), na.rm = TRUE),
    comp_tot = mean(
      c(
        comp1,
        comp2,
        comp3,
        comp4,
        comp5,
        comp6r,
        comp7r,
        comp8r,
        comp9r,
        comp10r
      ),
      na.rm = TRUE
    ),
    intel_tot = mean(
      c(
        intel1,
        intel2,
        intel3,
        intel4,
        intel5,
        intel6,
        intel7r,
        intel8r,
        intel9r,
        intel10r
      ),
      na.rm = TRUE
    ),
    open_tot = mean(
      c(
        open1,
        open2,
        open3,
        open4,
        open5,
        open6,
        open7r,
        open8r,
        open9r,
        open10r
      ),
      na.rm = TRUE
    )
  ) %>%
  na.omit() %>%
  select(id, green_tot, comp_tot, intel_tot, open_tot, student)
```

  > I ended up wanting to save this calculation into a new variable for later usage.

```{r}
items_data <- new_green_data %>%
  rowwise() %>%
  mutate(
    green_tot = mean(c(green1, green2r, green3, green4, green5), na.rm = TRUE),
    comp_tot = mean(
      c(
        comp1,
        comp2,
        comp3,
        comp4,
        comp5,
        comp6r,
        comp7r,
        comp8r,
        comp9r,
        comp10r
      ),
      na.rm = TRUE
    ),
    intel_tot = mean(
      c(
        intel1,
        intel2,
        intel3,
        intel4,
        intel5,
        intel6,
        intel7r,
        intel8r,
        intel9r,
        intel10r
      ),
      na.rm = TRUE
    ),
    open_tot = mean(
      c(
        open1,
        open2,
        open3,
        open4,
        open5,
        open6,
        open7r,
        open8r,
        open9r,
        open10r
      ),
      na.rm = TRUE
    )
  ) %>%
  na.omit()
```

  > Summary by students or non students.

```{r}
items_data %>%
  group_by(student) %>%
  summarize(
    green_mean = mean(green_tot, na.rm = TRUE),
    comp_mean = mean(comp_tot, na.rm = TRUE),
    intel_mean = mean(intel_tot, na.rm = TRUE),
    open_mean = mean(open_tot, na.rm = TRUE)
  )
```

### 3. Rescale the variables so that they go from 0-100 instead of the original range.
     Name the rescaled variables `*_pomp`.

  > I want to make sure that it is the variables that are being rescaled and later caculation can follow so I did this: 
  
```{r}
data_pomp <- new_green_data %>%
  mutate(across(
    c(green1:open10r & !student),
    ~ recode(
      .x,
      "1" = 0,
      "2" = 25,
      "3" = 50,
      "4" = 75,
      "5" = 100
    ),
    .names = "{.col}_pomp"
  ))
```

  > After I transform it, I wanted to produce a summary of the new data frame that included the pomps. 
  
```{r}
data_pomp %>% 
  summary()
```

### 4. Make plots that illustrate the distributions of the 4 POMP-scored variables.

  > I first started out by calculating the total of all of the "pomps" columns.

```{r}
data_pomp %>%
  rowwise() %>%
  mutate(
    green_tot_pomp = mean(
      c(
        green1_pomp,
        green2r_pomp,
        green3_pomp,
        green4_pomp,
        green5_pomp
      ),
      na.rm = TRUE
    ),
    comp_tot_pomp = mean(
      c(
        comp1_pomp,
        comp2_pomp,
        comp3_pomp,
        comp4_pomp,
        comp5_pomp,
        comp6r_pomp,
        comp7r_pomp,
        comp8r_pomp,
        comp9r_pomp,
        comp10r_pomp
      ),
      na.rm = TRUE
    ),
    intel_tot_pomp = mean(
      c(
        intel1_pomp,
        intel2_pomp,
        intel3_pomp,
        intel4_pomp,
        intel5_pomp,
        intel6_pomp,
        intel7r_pomp,
        intel8r_pomp,
        intel9r_pomp,
        intel10r_pomp
      ),
      na.rm = TRUE
    ),
    open_tot_pomp = mean(
      c(
        open1_pomp,
        open2_pomp,
        open3_pomp,
        open4_pomp,
        open5_pomp,
        open6_pomp,
        open7r_pomp,
        open8r_pomp,
        open9r_pomp,
        open10r_pomp
      ),
      na.rm = TRUE
    )
  ) %>%
  na.omit() %>%
  select(id,
         green_tot_pomp,
         comp_tot_pomp,
         intel_tot_pomp,
         open_tot_pomp,
         student)
```

<!-- BMW: I'm again confused as to why you have everything twice, once not assigned and once assigned? -->

  > I ended up wanting to create another variable containing the total for all of the pomps.

```{r}
pomp_tot_data <- data_pomp %>%
  rowwise() %>%
  mutate(
    green_tot_pomp = mean(
      c(
        green1_pomp,
        green2r_pomp,
        green3_pomp,
        green4_pomp,
        green5_pomp
      ),
      na.rm = TRUE
    ),
    comp_tot_pomp = mean(
      c(
        comp1_pomp,
        comp2_pomp,
        comp3_pomp,
        comp4_pomp,
        comp5_pomp,
        comp6r_pomp,
        comp7r_pomp,
        comp8r_pomp,
        comp9r_pomp,
        comp10r_pomp
      ),
      na.rm = TRUE
    ),
    intel_tot_pomp = mean(
      c(
        intel1_pomp,
        intel2_pomp,
        intel3_pomp,
        intel4_pomp,
        intel5_pomp,
        intel6_pomp,
        intel7r_pomp,
        intel8r_pomp,
        intel9r_pomp,
        intel10r_pomp
      ),
      na.rm = TRUE
    ),
    open_tot_pomp = mean(
      c(
        open1_pomp,
        open2_pomp,
        open3_pomp,
        open4_pomp,
        open5_pomp,
        open6_pomp,
        open7r_pomp,
        open8r_pomp,
        open9r_pomp,
        open10r_pomp
      ),
      na.rm = TRUE
    )
  )
```

  > I then calculated the mean of the total for the pomps and group them by student.

```{r}
pomp_tot_data %>% 
  group_by(student) %>% 
  summarize(green_mean_pomp = mean(green_tot_pomp, na.rm = TRUE),
            comp_mean_pomp = mean(comp_tot_pomp, na.rm = TRUE),
            intel_mean_pomp = mean(intel_tot_pomp, na.rm = TRUE),
            open_mean_pomp = mean(open_tot_pomp, na.rm = TRUE))
```

  > Now I start the ggplot process.

```{r}
green_tot_histo <- pomp_tot_data %>% 
ggplot() +
aes(x = green_tot_pomp) +
  geom_histogram(fill = "red") +
  theme_classic()
```

```{r}
comp_tot_histo  <- pomp_tot_data %>% 
ggplot() +
aes(x = comp_tot_pomp) +
  geom_histogram(fill = "green") +
  theme_classic()
```

```{r}
intel_tot_histo <- pomp_tot_data %>% 
ggplot() +
aes(x = intel_tot_pomp) +
  geom_histogram(fill = "blue") +
  theme_classic()
```

```{r}
open_tot_histo <- pomp_tot_data %>% 
ggplot() +
aes(x = open_tot_pomp) +
  geom_histogram(fill = "orange") +
  theme_classic()
```

  > I decided to group the graphs together for easier comparison.
  
```{r}
grid.arrange(green_tot_histo, 
             comp_tot_histo, 
             intel_tot_histo, 
             open_tot_histo)
```
  > The result indicated that green personality seems to have a more scattered data points throughout than the rest and sseemed to be the most normally distributed. Intel seems to be a little bitof a bimodel, open tot is slightly right skewed. The Comp personality is also slightly right skewed with its average being approximately around 70 to 75.
  
  
### 5. Make scatterplots showing the relationships between **green reputation** and each personality trait.
     Include trend lines for **students** and **non-students**.
     What do these plots show?
     
 > I started this with building the scatterplot from the perviously used variable to compute the mean of the total pomp columns.
 
```{r}
pomp_tot_data %>% 
  filter(!is.na(student)) %>% # BMW: You don't have any NAs for student since you coded them as "No_Response"
  ggplot() +
  aes(x = green_tot_pomp, y = comp_tot_pomp, color = student, fill = student) +
  geom_jitter(alpha = .5, size = 3, height = .5, width = .5) + # BMW: If you use geom_jitter() instead of geom_point() with continuous variables, be sure to adjust the height and width so that it is a very small amount
  geom_smooth(method = "lm")
```
  

```{r}
pomp_tot_data %>% 
  filter(!is.na(student)) %>% 
  ggplot() +
  aes(x = green_tot_pomp, y = intel_tot_pomp, color = student, fill = student) +
  geom_jitter(alpha = .5, size = 3, height = .5, width = .5) +
  geom_smooth(method = "lm")
```

```{r}
pomp_tot_data %>% 
  filter(!is.na(student)) %>% 
  ggplot() +
  aes(x = green_tot_pomp, y = open_tot_pomp, color = student, fill = student) +
  geom_jitter(alpha = .5, size = 3, height = .5, width = .5) +
  geom_smooth(method = "lm")
```

  > In all of the scatterplots, it can be said that there is a moderate positive correlation between green personality and other personalities. The relation between green personality and other personality is a positive one due to the effect it has on each other at a certain threshold although the evidence is not so clear on this matter. Students and non-students also seems to have a positive correlation with the personality factors with the exception of the non-respondent seeing a negative correlation. As the non-respondents' green personality goes up, their comp, intel, and open seem to go down.Comp, Open seems to have the greatest impact on students and their green personality.Students also seem to have a higher postive correlation at the end than non-students.

### 6. Compare **green reputation** for students and non-students using a **rainfall plot** (bar + density + data points).

```{r}
pomp_tot_data %>% 
  filter(!is.na(student)) %>% 
  ggplot() +
  aes(x = green_tot_pomp, color = student, fill = student) +
  geom_bar()
```

<!-- BMW: This isn't a rainfall plot as demonstrated in class. See below. -->

```{r}
pomp_tot_data %>% 
  drop_na(green_tot_pomp) %>% 
  ggplot() +
  aes(x = green_tot_pomp, y = student, color = student, fill = student) +
  geom_jitter(width = 0, height = .1) +
  geom_boxplot(color = "black", fill = "transparent", width = .2) +
  ggdist::stat_slab(height = .3, alpha = .5, position = position_nudge(y = .15))
  
```

  > The green reputation for students and non-students seems to be similar (approximately 50 to 60 green personalty score) with the knowledge that not a lot of non-students participated in the study, which means that the ratio is unbalanced.

### 7. Compute a summary table of means, SDs, medians, minima, and maxima for the four total scores for students and non-students.

  
```{r}
  pomp_tot_data %>% 
  group_by(student) %>% 
  summarize(across(green_tot_pomp:open_tot_pomp,
  list(mean = ~ mean(.x, na.rm= TRUE),
                sd = ~ sd(.x, na.rm = TRUE),
                min = ~ min(.x, na.rm = TRUE),
                max = ~ max(.x, na.rm = TRUE))))
```

```{r}
pomp_summ_table <- pomp_tot_data %>% 
  group_by(student) %>% 
  summarize(across(green_tot_pomp:open_tot_pomp,
  list(mean = ~ mean(.x, na.rm= TRUE),
                sd = ~ sd(.x, na.rm = TRUE),
                min = ~ min(.x, na.rm = TRUE),
                max = ~ max(.x, na.rm = TRUE))))
```

  > Here is the final calcualtion (summary table for the pomp values).
  
```{r}
print(pomp_summ_table)
```

  
In your assignment, prepare an RMarkdown file that includes both the coding and (for 4-7) narrative descriptions of your results.
